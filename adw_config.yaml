project_name: Vexora Enterprise Authentication & Authorization System
description: 'Implementing: SSO Authentication, Benutzerverwaltung, Rollenbasierte Zugriffskontrolle (RBAC) (+9 more)'
existing_functionality:
- Single-User RAG-System ohne Authentifizierung
- Dokument-Upload und -Verarbeitung
- RAG-basierte Chat-Funktion mit Ollama
- Weaviate Vektor-Suche
- PostgreSQL Dokumenten-Speicherung
- Real-time Streaming Responses
- Multiple Conversation Management
- Markdown Rendering mit Code Syntax Highlighting
requirements:
- name: SSO Authentication
  priority: high
  libraries:
  - arctic
  - '@azure/msal-node'
  - jsonwebtoken
  - bcrypt
  - express-session
  implementation_scope:
  - OAuth2 Authorization Code Flow mit PKCE
  - Microsoft Entra ID Integration
  - Google Workspace Integration
  - JWT-Token Generation und Validierung
  - Refresh-Token Flow
  - Automatische Profil-Erstellung beim ersten Login
  constraints:
  - Login < 5 Sekunden
  - JWT signiert mit min 256 Bit Secret
  - HTTPS fuer OAuth2-Callbacks in Produktion
  - Access-Token 15min, Refresh-Token 30 Tage
  success_criteria:
  - Login mit Microsoft/Google funktioniert
  - Session 7 Tage gueltig mit Refresh-Token
  - Logout invalidiert Token
  out_of_scope:
  - SAML SSO
  - 2FA/MFA
  - Passwort-Reset
- name: Benutzerverwaltung
  priority: high
  libraries: []
  implementation_scope:
  - Admin-UI fuer Benutzer anzeigen, Rollen zuweisen, Abteilungen zuordnen
  - Benutzer deaktivieren und Profile bearbeiten
  - Benutzer-Profil ansehen/bearbeiten (Self-Service)
  - PostgreSQL users-Tabelle (id, email, name, role, department, provider)
  - Audit-Trail fuer Benutzeraenderungen
  constraints:
  - Nur Admins verwalten Benutzer
  - Mindestens ein Admin muss existieren
  - Email eindeutig
  success_criteria:
  - Admin kann Rollen/Abteilungen zuweisen
  - Deaktivierte Benutzer koennen sich nicht anmelden
  out_of_scope:
  - Gruppen/Teams
  - Einladungen
  - Self-Service-Registrierung
- name: Rollenbasierte Zugriffskontrolle (RBAC)
  priority: high
  libraries: []
  implementation_scope:
  - 'Drei Rollen: Employee, Manager, Admin'
  - 'Employee: Eigene Dokumente'
  - 'Manager: Abteilungs-Dokumente'
  - 'Admin: Alle Dokumente + System-Einstellungen'
  - Rollen definieren API-Zugriff und UI-Sichtbarkeit
  constraints:
  - Ein Benutzer = eine Rolle
  - Rollenwechsel nur durch Admin
  success_criteria:
  - Employee sieht nur eigene Dokumente
  - Manager sieht Abteilungs-Dokumente
  - Admin sieht alles
  out_of_scope:
  - Custom Roles
  - Rollen-Hierarchien
  - Mehrere Rollen pro Benutzer
- name: Dokument-Berechtigungen
  priority: high
  libraries: []
  implementation_scope:
  - 'Dokument-Attribute: Owner, Department, Classification, Allowed Roles, Allowed Users'
  - 'Klassifikationsstufen: public, internal, confidential, restricted'
  - Berechtigungen beim Upload festlegbar
  - Nachtraegliche Aenderung durch Owner/Admin
  constraints:
  - Employee max 'internal'
  - Manager max 'confidential'
  - Aenderungen sofort wirksam
  success_criteria:
  - Classification bestimmt Sichtbarkeit
  - RAG-Suche respektiert Berechtigungen automatisch
  out_of_scope:
  - Zeitlich begrenzte Berechtigungen
  - Externe Freigabe-Links
- name: PostgreSQL Row Level Security (RLS)
  priority: high
  libraries: []
  implementation_scope:
  - RLS auf documents-Tabelle aktivieren
  - 'Policies: public, department, owner, role, user, admin'
  - Automatische Filterung transparent fuer Anwendungscode
  - Benutzerkontext via SET LOCAL (user_id, role, department)
  constraints:
  - Performance < 50ms
  - Policies vor jeder Query setzen
  success_criteria:
  - SELECT * FROM documents zeigt nur autorisierte Dokumente
  - Marketing sieht keine HR-Dokumente
  out_of_scope:
  - RLS auf anderen Tabellen
  - Dynamische Policy-Generierung
- name: Secure RAG Service
  priority: high
  libraries: []
  implementation_scope:
  - 'VOR Vektor-Suche: Benutzerkontext ermitteln, RLS setzen, erlaubte document_ids abrufen'
  - Weaviate Filter mit erlaubten document_ids erstellen
  - Filterung VOR Suche (nicht Post-Processing)
  - Verifizieren dass Chunks autorisiert sind
  - Nur sichtbare Source Citations anzeigen
  - Audit-Log fuer RAG-Queries
  constraints:
  - Performance +100ms max gegenueber ungefiltert
  - Zero Information Leakage
  - 'Anti-Pattern vermeiden: Post-Processing Filterung'
  success_criteria:
  - Marketing fragt 'Gehaelter' -> Keine HR-Daten
  - Nur autorisierte Citations anzeigen
  out_of_scope:
  - Query-Rewriting zur Umgehung
  - Partial Results
- name: API-Authentifizierung
  priority: high
  libraries: []
  implementation_scope:
  - JWT-Token in Authorization-Header erforderlich
  - Token-Validierung Middleware
  - 401 Unauthorized bei fehlendem/ungueltigem Token
  - 403 Forbidden bei fehlenden Berechtigungen
  - 'Geschuetzte Endpunkte: /api/rag/*, /api/chat/*, /api/ollama/*'
  constraints:
  - Middleware < 10ms Overhead
  - Token-Refresh unterstuetzen
  success_criteria:
  - Ohne Token -> 401
  - Mit gueltigem Token -> Benutzer-Kontext verfuegbar
  out_of_scope:
  - API-Keys
  - Rate Limiting
  - IP-Restriktion
- name: Frontend Login & Session
  priority: high
  libraries:
  - react-router-dom
  - axios
  implementation_scope:
  - Login-Seite mit Microsoft/Google SSO-Buttons (separate Route /login)
  - OAuth2 Redirect-Flow
  - JWT in localStorage oder httpOnly-Cookie
  - Auto-Refresh mit Refresh-Token
  - ProtectedRoute Komponente (schuetzt /chat und /documents Routen)
  - 'React Router Setup mit Routes: /login, /chat, /documents'
  - Benutzer-Menu in Navbar (Profil, Logout)
  constraints:
  - Responsiv (Mobile + Desktop)
  - Token nicht in URL
  success_criteria:
  - SSO-Flow funktioniert (OAuth2 -> Redirect zu /chat)
  - Nicht-authentifizierte Benutzer werden zu /login redirected
  - ProtectedRoute schuetzt /chat und /documents Routen
  - Navbar zeigt Benutzernamen
  - Logout leitet zu /login um
  out_of_scope:
  - Profil-Bearbeitung
  - Passwort-Aenderung
  - Session-Historie
- name: Audit Logging
  priority: medium
  libraries: []
  implementation_scope:
  - 'Protokollieren: Logins, Dokument-Uploads, RAG-Queries, Berechtigungsaenderungen, Admin-Aktionen'
  - 'Log-Eintraege: Timestamp, User-ID, Email, Aktion, Ressource, Ergebnis'
  - PostgreSQL audit_logs Tabelle
  - 90 Tage Aufbewahrung
  - Admin-Zugriff auf Logs
  - Append-only (Manipulationsschutz)
  constraints:
  - Keine Performance-Einbussen
  - Keine sensiblen Daten in Logs
  success_criteria:
  - Admin sieht Upload/Query-Historie
  - Fehlgeschlagene Logins protokolliert
  out_of_scope:
  - Echtzeit-Alerting
  - SIEM-Integration
  - Log-Export
- name: Upload mit Berechtigungen
  priority: high
  libraries: []
  implementation_scope:
  - Upload-UI mit Classification Dropdown
  - 'Sichtbarkeit: nur ich, Abteilung, alle'
  - Multi-Select fuer spezifische Benutzer
  - Owner und Department automatisch setzen
  - Default-Classification basierend auf Rolle
  - Berechtigungen in PostgreSQL + Weaviate speichern
  - Vorschau effektiver Berechtigungen
  constraints:
  - Employee max 'internal'
  - Manager max 'confidential'
  - Nachtraegliche Aenderung moeglich (Owner/Admin)
  success_criteria:
  - Upload zeigt Berechtigungsoptionen
  - Berechtigungen korrekt gespeichert
  out_of_scope:
  - Bulk-Upload mit Berechtigungen
  - Template-Berechtigungen
- name: Intelligent RAG Activation (Smart Auto)
  priority: high
  libraries: []
  implementation_scope:
  - RAG aktiviert sich automatisch bei relevanten Queries
  - Intent Detection (keyword-basiert)
  - Query analysieren ob firmenspezifisch
  - Source Citations anzeigen wenn RAG genutzt wurde
  - 'Settings: Immer an, Automatisch (default), Manueller Toggle'
  constraints:
  - Intent Detection < 50ms
  - Kein RAG bei Smalltalk (Performance)
  - 'Transparenz: User muss wissen ob RAG aktiv war'
  success_criteria:
  - '''Was ist unsere Pricing-Strategie?'' -> RAG laeuft automatisch'
  - '''Wie gehts?'' -> Kein RAG'
  - User sieht '3 Quellen gefunden' oder keine Anzeige
  out_of_scope:
  - Komplexe LLM-basierte Intent Detection
- name: Document Management Page
  priority: high
  libraries:
  - socket.io-client
  - react-router-dom
  implementation_scope:
  - Dedizierte Route /documents mit React Router (separate Seite, NICHT Sidebar)
  - Vollbild-Seite fuer Dokumente (gesamter Viewport, kein Sidebar-Panel)
  - 'Header Navigation mit Links: Chat | Dokumente (Page-Wechsel via React Router)'
  - Upload-Bereich mit Drag & Drop + Permission-Panel
  - Storage-Quota-Anzeige
  - Filter & Suche (Kategorie, Tags, Name)
  - Document-Table (sortierbar, filterbar, selectable)
  - Bulk-Actions (Multi-Select, Bulk-Delete)
  - Permission-Badges und Inline-Actions
  - Echtzeit-Updates via Socket.io
  constraints:
  - Responsiv (Mobile + Desktop)
  - 1000+ Dokumente ohne Performance-Probleme
  success_criteria:
  - User kann zur separaten /documents Seite navigieren (nicht Sidebar)
  - Dokumente-Seite nutzt vollen Bildschirm
  - Navigation zwischen Chat und Documents funktioniert (React Router)
  - User findet Dokumente in < 3 Klicks
  - Table-Sorting/Filtering funktioniert
  - Permission-Badges zeigen Zugriff klar
  - Storage-Quota sichtbar
  out_of_scope:
  - Sidebar-basiertes Document Management (muss separate Seite sein)
  - Document-Preview
  - Annotations
  - Grid-View
tech_stack:
  new_dependencies:
    npm:
    - arctic@^3.7.0
    - '@azure/msal-node@^3.8.5'
    - jsonwebtoken@^9.0.3
    - bcrypt@^6.0.0
    - express-session@^1.18.2
    - react-router-dom@^7.12.0
    - axios
    - '@types/jsonwebtoken@^9.0.7'
    - '@types/bcrypt@^5.0.2'
    - '@types/express-session@^1.18.0'
    pip: []
  apis_to_create:
  - endpoint: GET /api/auth/microsoft
    description: Initiiere Microsoft OAuth2 Login
    authentication: none
  - endpoint: GET /api/auth/microsoft/callback
    description: Microsoft OAuth2 Callback Handler
    authentication: none
  - endpoint: GET /api/auth/google
    description: Initiiere Google OAuth2 Login
    authentication: none
  - endpoint: GET /api/auth/google/callback
    description: Google OAuth2 Callback Handler
    authentication: none
  - endpoint: POST /api/auth/logout
    description: Logout und Token invalidieren
    authentication: JWT required
  - endpoint: GET /api/auth/me
    description: Aktuellen Benutzer abrufen
    authentication: JWT required
  - endpoint: POST /api/auth/refresh
    description: Access-Token mit Refresh-Token erneuern
    authentication: Refresh-Token required
  - endpoint: GET /api/users
    description: Alle Benutzer auflisten
    authentication: JWT required, Admin only
  - endpoint: GET /api/users/:id
    description: Einzelnen Benutzer abrufen
    authentication: JWT required
  - endpoint: PUT /api/users/:id
    description: Benutzer aktualisieren
    authentication: JWT required, Admin only
  - endpoint: PUT /api/users/:id/role
    description: Benutzer-Rolle aendern
    authentication: JWT required, Admin only
  - endpoint: PUT /api/users/:id/deactivate
    description: Benutzer deaktivieren
    authentication: JWT required, Admin only
  - endpoint: GET /api/audit/logs
    description: Audit-Logs abrufen
    authentication: JWT required, Admin only
  - endpoint: GET /api/audit/logs/user/:id
    description: Audit-Logs fuer Benutzer
    authentication: JWT required, Admin only
  database_changes:
  - CREATE TABLE users (id, email UNIQUE, name, role, department, provider, provider_id, is_active, created_at, last_login)
  - CREATE TABLE refresh_tokens (id, user_id, token_hash, expires_at, created_at)
  - CREATE TABLE audit_logs (id, user_id, user_email, action, resource_type, resource_id, result, ip_address, user_agent,
    metadata JSONB, created_at)
  - ALTER TABLE documents ADD COLUMN owner_id, department, classification, allowed_roles[], allowed_users[]
  - CREATE INDEX users_email_idx ON users(email)
  - CREATE INDEX users_provider_idx ON users(provider, provider_id)
  - CREATE INDEX documents_owner_idx ON documents(owner_id)
  - CREATE INDEX documents_department_idx ON documents(department)
  - CREATE INDEX documents_classification_idx ON documents(classification)
  - CREATE INDEX audit_logs_user_created_idx ON audit_logs(user_id, created_at)
  - CREATE INDEX audit_logs_action_created_idx ON audit_logs(action, created_at)
  - ALTER TABLE documents ENABLE ROW LEVEL SECURITY
  - CREATE POLICY documents_public_policy ON documents
  - CREATE POLICY documents_department_policy ON documents
  - CREATE POLICY documents_owner_policy ON documents
  - CREATE POLICY documents_role_policy ON documents
  - CREATE POLICY documents_user_policy ON documents
  - CREATE POLICY documents_admin_policy ON documents
apps:
- name: frontend
  path: .
  type: frontend
  default_port: 5173
conventions:
  version: 2
  created_at: '2026-01-22T00:11:01.287858Z'
  source: anthropic-discovery
  state_management:
    system: React Context API
    stores_location: Typischerweise in src/context/ oder src/providers/ Ordnern
    pattern: Das Projekt nutzt die React Context API für Zustandsverwaltung, aber spezifische Implementierungsdetails sind
      aus den bereitgestellten Codebase-Informationen nicht ersichtlich. Die Context API wird typischerweise für globale Zustände
      wie Authentifizierung, Theme-Management oder Anwendungskonfiguration verwendet.
    usage_pattern: |-
      // Beispiel für typische React Context Verwendung
      const AppContext = createContext();

      export const AppProvider = ({ children }) => {
        const [state, setState] = useState(initialState);
        return (
          <AppContext.Provider value={{ state, setState }}>
            {children}
          </AppContext.Provider>
        );
      };

      // Verwendung in Komponenten
      const { state, setState } = useContext(AppContext);
    reference_files:
    - <UNKNOWN>
    - <UNKNOWN>
    - <UNKNOWN>
    guidelines:
    - Context nur für wirklich globale Zustände verwenden
    - Provider auf höchster erforderlicher Ebene platzieren
    - Custom Hooks für Context-Zugriff erstellen
    - State-Updates über Reducer-Pattern für komplexe Zustände
    - Performance-Optimierung durch Context-Aufspaltung bei Bedarf
    enforcement: optional
    consistency_score: 0
    reason: Da nur 0% der Dateien React Context API verwenden, ist eine optionale Durchsetzung angemessen - die Projektbasis
      nutzt bereits alternative State-Management-Lösungen, die funktionieren. Context sollte nur als bewusste architektonische
      Entscheidung für wirklich globale Zustände eingeführt werden.
    rules:
    - IMMER custom Hooks für Context-Zugriff erstellen anstatt useContext direkt zu verwenden
    - NIEMALS Context für lokale Komponentenzustände verwenden - nur für wirklich globale Daten
    - IMMER Provider auf der höchstmöglichen erforderlichen Ebene platzieren, nicht an der App-Wurzel
    - IMMER TypeScript-Interfaces für Context-Werte definieren um Type-Safety zu gewährleisten
    - NIEMALS multiple unabhängige Zustände in einem Context kombinieren - Context aufsplitten für Performance
    violations:
    - example: const { user, theme, notifications } = useContext(AppContext);
      why: Direkter useContext-Zugriff ohne custom Hook macht Testing schwer und verletzt Abstraktion
      fix: const { user, theme, notifications } = useAppContext(); // Custom Hook verwenden
    - example: const LocalContext = createContext(); // In Komponente für lokalen State
      why: Context für lokale Zustände ist Overhead - useState oder useReducer sind effizienter
      fix: const [localState, setLocalState] = useState(initialValue); // Lokalen State verwenden
    - example: |-
        export const AppProvider = ({ children }) => {
          return (
            <UserContext.Provider>
              <ThemeContext.Provider>
                <NotificationContext.Provider>
                  {children}
                </NotificationContext.Provider>
              </ThemeContext.Provider>
            </UserContext.Provider>
          );
        };
      why: Verschachtelte Provider für unabhängige Zustände verursachen unnötige Re-Renders
      fix: |-
        // Separate Provider nur dort wo benötigt
        <UserProvider>
          <UserDashboard />
        </UserProvider>
        <ThemeProvider>
          <App />
        </ThemeProvider>
    - example: const AppContext = createContext(); // Ohne TypeScript Interface
      why: Fehlende Typisierung führt zu Runtime-Fehlern und schlechter Developer Experience
      fix: |-
        interface AppContextType {
          state: AppState;
          actions: AppActions;
        }
        const AppContext = createContext<AppContextType | undefined>(undefined);
    analyzed_at: '2026-01-22T00:07:52.053538Z'
    sample_size: 36
    available_components: null
  styling:
    system: TailwindCSS
    config_path: tailwind.config.js
    usage_pattern: |-
      className={`
        w-full flex items-center justify-between
        px-4 py-2 text-xs font-medium uppercase tracking-wider
        transition-colors duration-150
        ${isDark
          ? 'text-gray-400 hover:text-gray-300 hover:bg-white/5'
          : 'text-gray-500 hover:text-gray-700 hover:bg-black/5'
        }
      `}
    reference_files:
    - src/components/ConversationGroup.tsx
    - src/components/ConfirmDialog.tsx
    - src/components/RAGToggle.tsx
    - src/components/StorageQuotaAlert.tsx
    - src/contexts/ThemeContext.tsx
    guidelines:
    - 'Verwende immer bedingte Klassen für Theme-Support: `{isDark ? ''dark-classes'' : ''light-classes''}`'
    - Nutze Template-Literals mit .trim() für mehrzeilige className-Strings
    - Setze transition-colors für smooth Theme-Wechsel ein
    - 'Verwende semantische Farb-Token: text-primary, bg-surface, border-white/10'
    - 'Benutze Opacity-Modifier für subtile Effekte: bg-white/5, text-gray-400'
    - Implementiere responsive Design mit Tailwind-Breakpoints
    - 'Nutze Flex-Layout für konsistente Layouts: flex, items-center, justify-between'
    - Verwende rounded-lg für konsistente Border-Radius
    - 'Setze focus-Styles für Accessibility: focus:outline-none, focus:ring-2'
    - Nutze hover-States für interaktive Elemente
    enforcement: mandatory
    consistency_score: 100
    reason: Diese Konvention ist obligatorisch, da 100% der Dateien einheitlich TailwindCSS mit bedingten Klassen für Theme-Support
      verwenden. Die konsistente Implementierung von Theme-Wechseln ist kritisch für die Benutzerfreundlichkeit und muss projektübergreifend
      einheitlich sein.
    rules:
    - 'VERWENDE IMMER bedingte Klassen für Theme-Support mit dem Muster `{isDark ? ''dark-classes'' : ''light-classes''}`'
    - NUTZE IMMER Template-Literals mit mehrzeiligen className-Strings für komplexe Styling
    - SETZE IMMER transition-colors für glatte Übergänge bei Theme-Wechseln ein
    - VERWENDE NIEMALS statische className-Strings wenn Theme-Support erforderlich ist
    - NUTZE IMMER Opacity-Modifier (bg-white/5, text-gray-400) für subtile visuelle Effekte
    violations:
    - example: className="text-gray-500 hover:text-gray-700 bg-white"
      why: Statische Klassen unterstützen keinen Theme-Wechsel und brechen die Konsistenz
      fix: 'className={`text-gray-500 hover:text-gray-700 ${isDark ? ''bg-gray-800'' : ''bg-white''}`}'
    - example: 'className={isDark ? "text-white bg-black" : "text-black bg-white"}'
      why: Fehlende Transition-Klassen führen zu abrupten visuellen Übergängen
      fix: 'className={`transition-colors duration-150 ${isDark ? ''text-white bg-black'' : ''text-black bg-white''}`}'
    - example: className="w-full flex items-center px-4 py-2 text-gray-500"
      why: Template-Literals fehlen für mehrzeilige Organisation und Theme-Support
      fix: |-
        className={`
          w-full flex items-center
          px-4 py-2
          ${isDark ? 'text-gray-400' : 'text-gray-500'}
        `}
    - example: 'className={`hover:bg-gray-100 ${isDark ? ''text-gray-300'' : ''text-gray-600''}`}'
      why: Hover-States berücksichtigen nicht das aktuelle Theme und können visuell inkonsistent sein
      fix: 'className={`transition-colors ${isDark ? ''text-gray-300 hover:bg-white/5'' : ''text-gray-600 hover:bg-black/5''}`}'
    analyzed_at: '2026-01-22T00:08:39.429287Z'
    sample_size: 2
    available_components: null
  api:
    style: REST API
    location: src/lib/api.ts (Hauptmodul)
    usage_pattern: |-
      ```typescript
      // Health Check
      const health = await checkHealth();
      setIsOllamaConnected(health.services.ollama.status === 'ok');

      // Chat Streaming mit RAG
      await streamChat(
        allMessages,
        {
          onToken: (token) => currentContent += token,
          onSources: (sources: RAGSource[]) => updateSources(sources),
          onComplete: (response, metadata) => finalizeMessage()
        },
        {
          model,
          signal: abortController.signal,
          ragOptions: { enabled: true, query: content, searchLimit: 5 }
        }
      );

      // Dokumentenoperationen
      const result = await fetchDocuments();
      const uploaded = await uploadDocumentAsync(file, onProgress);
      await deleteDocument(id);
      ```
    reference_files:
    - src/App.tsx
    - src/contexts/DocumentContext.tsx
    - src/contexts/ChatContext.tsx
    - src/components/ModelSelector.tsx
    - src/components/ModelSettings.tsx
    guidelines:
    - Alle API-Funktionen werden aus dem zentralen `api.ts` Modul importiert
    - Streaming-APIs nutzen Callback-Pattern für Live-Updates
    - Umfassende TypeScript-Typen für alle Request/Response-Strukturen
    - AbortController für Stream-Cancellation implementieren
    - Konsistente Error-Handling-Strategien in allen Komponenten
    - RAG-Features werden als optionale Parameter in Chat-APIs integriert
    - Progress-Callbacks für Datei-Uploads und lange Operationen
    - Health-Checks für Service-Verfügbarkeit implementieren
    enforcement: optional
    consistency_score: 0
    reason: Da nur 0% der Dateien das zentrale API-Pattern verwenden, ist eine optionale Durchsetzung angemessen, um schrittweise
      Migration zu ermöglichen. Die bestehende dezentrale Struktur kann parallel existieren, während neue Features das einheitliche
      Pattern nutzen.
    rules:
    - IMMER alle API-Funktionen aus dem zentralen `api.ts` Modul importieren für neue Features
    - IMMER Callback-Pattern für Streaming-APIs mit onToken, onSources und onComplete implementieren
    - IMMER AbortController für Stream-Cancellation und Request-Abbruch bereitstellen
    - NIEMALS direkte Fetch-Aufrufe ohne zentrale Error-Handling-Strategien verwenden
    - IMMER TypeScript-Typen für alle Request/Response-Strukturen definieren und exportieren
    violations:
    - example: 'const response = await fetch(''/api/chat'', { method: ''POST'', body: JSON.stringify(data) });'
      why: Direkte Fetch-Aufrufe umgehen zentrales Error-Handling und Typisierung
      fix: import { streamChat } from '@/api'; await streamChat(messages, callbacks, options);
    - example: const stream = new EventSource('/api/stream'); stream.onmessage = (e) => setText(e.data);
      why: Manuelles Streaming ohne einheitliche Callback-Struktur und Fehlerbehandlung
      fix: 'await streamChat(messages, { onToken: (token) => setText(prev => prev + token), onComplete: handleComplete },
        options);'
    - example: 'const uploadFile = async (file) => { const formData = new FormData(); formData.append(''file'', file); return
        fetch(''/upload'', { method: ''POST'', body: formData }); };'
      why: Dezentrale Upload-Logik ohne Progress-Tracking und einheitliche Fehlerbehandlung
      fix: import { uploadDocumentAsync } from '@/api'; const result = await uploadDocumentAsync(file, (progress) => setUploadProgress(progress));
    - example: const checkStatus = () => fetch('/health').then(r => r.json());
      why: Fehlende Typisierung und inkonsistente Service-Health-Checks
      fix: 'import { checkHealth } from ''@/api''; const health: HealthResponse = await checkHealth(); setConnected(health.services.ollama.status
        === ''ok'');'
    analyzed_at: '2026-01-22T00:09:29.041402Z'
    sample_size: 17
    available_components: null
  authentication:
    system: Microsoft OAuth2 + JWT
    discovered_in_feature: 56
    discovered_at: '2026-01-22T00:47:18.211843Z'
    import_path: '@/contexts/AuthContext'
    reference_files:
    - src/contexts/AuthContext.tsx:1
    - src/components/ProtectedRoute.tsx:1
    - server/src/routes/auth.ts:1
    - server/src/services/AuthService.ts:1
    usage_pattern: '// Frontend: useAuth Hook\nconst { isAuthenticated, user, login, logout } = useAuth();\n\n// Protected
      Routes\n<ProtectedRoute requiredRole=\"Manager\">\n  <AdminPanel />\n</ProtectedRoute>\n\n// Backend: Auth Endpoints\n/api/auth/microsoft/login
      - Redirect to OAuth\n/api/auth/microsoft/callback - Handle OAuth callback\n/api/auth/me - Get current user\n/api/auth/logout
      - Logout and revoke tokens'
    guidelines:
    - Use httpOnly cookies for JWT tokens (security)
    - Implement refresh token rotation
    - Check user permissions with ProtectedRoute component
    - 'Use role hierarchy: Employee < Manager < Admin'
    - Always use AuthProvider at app root level
    - Handle 401 responses with automatic logout
    - Verify tokens server-side before database queries
  last_updated: '2026-01-22T00:47:18.212282Z'
  updated_by_feature: 56
